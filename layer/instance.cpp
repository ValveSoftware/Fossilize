/* Copyright (c) 2018 Hans-Kristian Arntzen
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include "instance.hpp"
#include "utils.hpp"
#include "path.hpp"
#include <mutex>
#include <unordered_map>
#include <memory>
#include "fossilize_application_filter.hpp"

#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#else
#include <unistd.h>
#endif
#include <signal.h>
#include "fossilize_inttypes.h"
#include "fossilize_errors.hpp"

namespace Fossilize
{
// We only need one global application info filter.
// We can kick off async parse of this as early as the layer is loaded, e.g. vkCreateInstance.
// Global ApplicationInfoFilter must outlive the recorder, so declare earlier in translation unit to guarantee this.
static std::unique_ptr<ApplicationInfoFilter> globalInfoFilter;
static std::mutex globalInfoFilterLock;
static bool globalInfoFilterDone;

#ifndef FOSSILIZE_APPLICATION_INFO_FILTER_PATH_ENV
#define FOSSILIZE_APPLICATION_INFO_FILTER_PATH_ENV "FOSSILIZE_APPLICATION_INFO_FILTER_PATH"
#endif

static ApplicationInfoFilter *getApplicationInfoFilter()
{
	std::lock_guard<std::mutex> lock(globalInfoFilterLock);
	if (globalInfoFilterDone)
		return globalInfoFilter.get();

#ifdef ANDROID
	const char *filterPath = nullptr;
#else
	const char *filterPath = getenv(FOSSILIZE_APPLICATION_INFO_FILTER_PATH_ENV);
#endif

	if (filterPath)
	{
		globalInfoFilter.reset(new ApplicationInfoFilter);
		globalInfoFilter->set_environment_resolver([](const char *env, void *) -> const char * {
			return getenv(env);
		}, nullptr);
		globalInfoFilter->parse_async(filterPath);
	}

	globalInfoFilterDone = true;
	return globalInfoFilter.get();
}

void Instance::init(VkInstance instance_, const VkApplicationInfo *pApp, VkLayerInstanceDispatchTable *pTable_, PFN_vkGetInstanceProcAddr gpa_)
{
	infoFilter = getApplicationInfoFilter();
	instance = instance_;
	pTable = pTable_;
	gpa = gpa_;

	// pNext in appInfo is not supported.
	if (pApp && !pApp->pNext)
	{
		pAppInfo = alloc.allocate<VkApplicationInfo>();
		*pAppInfo = *pApp;

		if (pApp->pApplicationName)
		{
			size_t len = strlen(pApp->pApplicationName) + 1;
			char *pAppName = alloc.allocate_n<char>(len);
			memcpy(pAppName, pApp->pApplicationName, len);
			pAppInfo->pApplicationName = pAppName;
		}

		if (pApp->pEngineName)
		{
			size_t len = strlen(pApp->pEngineName) + 1;
			char *pEngineName = alloc.allocate_n<char>(len);
			memcpy(pEngineName, pApp->pEngineName, len);
			pAppInfo->pEngineName = pEngineName;
		}
	}
}

// Make this global to the process so we can share pipeline recording across VkInstances as well in-case an application is using external memory sharing techniques, (VR?).
// We only access this data structure on device creation, so performance is not a real concern.
static std::mutex recorderLock;

struct Recorder
{
	std::unique_ptr<DatabaseInterface> interface;
	std::unique_ptr<StateRecorder> recorder;
};
static std::unordered_map<Hash, Recorder> globalRecorders;

#ifdef ANDROID
static std::string getSystemProperty(const char *key)
{
	// Environment variables are not easy to set on Android.
	// Make use of the system properties instead.
	char value[256];
	char command[256];
	snprintf(command, sizeof(command), "getprop %s", key);

	// __system_get_property is apparently removed in recent NDK, so just use popen.
	size_t len = 0;
	FILE *file = popen(command, "rb");
	if (file)
	{
		len = fread(value, 1, sizeof(value) - 1, file);
		// Last character is a newline, so remove that.
		if (len > 1)
			value[len - 1] = '\0';
		else
			len = 0;
		fclose(file);
	}

	return len ? value : "";
}
#endif

#ifndef FOSSILIZE_DUMP_PATH_ENV
#define FOSSILIZE_DUMP_PATH_ENV "FOSSILIZE_DUMP_PATH"
#endif

#ifndef FOSSILIZE_LOG_PATH_ENV
#define FOSSILIZE_LOG_PATH_ENV "FOSSILIZE_LOG_PATH"
#endif

#ifndef FOSSILIZE_DUMP_PATH_READ_ONLY_ENV
#define FOSSILIZE_DUMP_PATH_READ_ONLY_ENV "FOSSILIZE_DUMP_PATH_READ_ONLY"
#endif

#ifdef FOSSILIZE_LAYER_CAPTURE_SIGSEGV
static thread_local const VkComputePipelineCreateInfo *tls_compute_create_info = nullptr;
static thread_local const VkGraphicsPipelineCreateInfo *tls_graphics_create_info = nullptr;
static thread_local const VkRayTracingPipelineCreateInfoKHR *tls_raytracing_create_info = nullptr;
static thread_local StateRecorder *tls_recorder = nullptr;

static bool emergencyRecord()
{
	bool ret = false;
	if (tls_recorder)
	{
		if (tls_graphics_create_info)
			ret = tls_recorder->record_graphics_pipeline(VK_NULL_HANDLE, *tls_graphics_create_info, nullptr, 0);
		if (tls_compute_create_info)
			ret = tls_recorder->record_compute_pipeline(VK_NULL_HANDLE, *tls_compute_create_info, nullptr, 0);
		if (tls_raytracing_create_info)
			ret = tls_recorder->record_raytracing_pipeline(VK_NULL_HANDLE, *tls_raytracing_create_info, nullptr, 0);

		// Flush out the recording thread.
		tls_recorder->tear_down_recording_thread();
	}

	return ret;
}

#ifdef _WIN32
static LONG WINAPI crashHandler(_EXCEPTION_POINTERS *)
{
	LOGE_LEVEL("Caught segmentation fault! Emergency serialization of state to disk ...\n");
	emergencyRecord();
	LOGE_LEVEL("Done with emergency serialization, hopefully this worked :D\n");

	MessageBoxA(nullptr, "Pipeline creation triggered an access violation, the offending state was serialized. The application will now terminate.",
	            "Pipeline creation access violation", 0);

	// Clean exit instead of reporting the segfault.
	// Use exit code 2 to mark a segfaulted child.
	ExitProcess(2);
	return EXCEPTION_EXECUTE_HANDLER;
}

static void installSegfaultHandler()
{
	// Setup a last resort SEH handler. This overrides any global messagebox saying "application crashed",
	// which is what we want.
	SetErrorMode(SEM_NOGPFAULTERRORBOX | SEM_FAILCRITICALERRORS);
	SetUnhandledExceptionFilter(crashHandler);
}
#else
static void segfaultHandler(int sig)
{
	LOGE_LEVEL("Caught segmentation fault! Emergency serialization of state to disk ...\n");
	emergencyRecord();
	LOGE_LEVEL("Done with emergency serialization, hopefully this worked :D\n");

	// Now we can die properly.
	raise(sig);
}

static void installSegfaultHandler()
{
	struct sigaction sa = {};
	sa.sa_flags = SA_RESETHAND;
	sigemptyset(&sa.sa_mask);
	sa.sa_handler = segfaultHandler;

	if (sigaction(SIGSEGV, &sa, nullptr) < 0)
		LOGE_LEVEL("Failed to install SIGSEGV handler!\n");
	if (sigaction(SIGFPE, &sa, nullptr) < 0)
		LOGE_LEVEL("Failed to install SIGFPE handler!\n");
	if (sigaction(SIGABRT, &sa, nullptr) < 0)
		LOGE_LEVEL("Failed to install SIGABRT handler!\n");
}
#endif

void Instance::braceForGraphicsPipelineCrash(StateRecorder *recorder,
                                             const VkGraphicsPipelineCreateInfo *info)
{
	tls_recorder = recorder;
	tls_graphics_create_info = info;
	tls_compute_create_info = nullptr;
	tls_raytracing_create_info = nullptr;
}

void Instance::braceForComputePipelineCrash(StateRecorder *recorder,
                                            const VkComputePipelineCreateInfo *info)
{
	tls_recorder = recorder;
	tls_compute_create_info = info;
	tls_graphics_create_info = nullptr;
	tls_raytracing_create_info = nullptr;
}

void Instance::braceForRayTracingPipelineCrash(StateRecorder *recorder,
                                               const VkRayTracingPipelineCreateInfoKHR *info)
{
	tls_recorder = recorder;
	tls_compute_create_info = nullptr;
	tls_graphics_create_info = nullptr;
	tls_raytracing_create_info = info;
}

void Instance::completedPipelineCompilation()
{
	tls_recorder = nullptr;
	tls_graphics_create_info = nullptr;
	tls_compute_create_info = nullptr;
	tls_raytracing_create_info = nullptr;
}
#endif

Instance::Instance()
{
#ifdef FOSSILIZE_LAYER_CAPTURE_SIGSEGV
#ifdef ANDROID
	auto sigsegv = getSystemProperty("debug.fossilize.dump_sigsegv");
	if (!sigsegv.empty() && strtoul(sigsegv.c_str(), nullptr, 0) != 0)
	{
		installSegfaultHandler();
		enableCrashHandler = true;
	}
#else
	const char *sigsegv = getenv("FOSSILIZE_DUMP_SIGSEGV");
	if (sigsegv && strtoul(sigsegv, nullptr, 0) != 0)
	{
		installSegfaultHandler();
		enableCrashHandler = true;
	}
#endif
#endif

	const char *log_path = getenv(FOSSILIZE_LOG_PATH_ENV);
	if (log_path)
	{
		log_file = fopen(log_path, "w");
		setLogCallback();
	}
}

Instance::~Instance()
{
	set_thread_log_callback(nullptr, nullptr);
	if (log_file)
		fclose(log_file);
}

void Instance::setLogCallback()
{
	if (log_file)
	{
		set_thread_log_callback([](LogLevel, const char *message, void *userdata) {
			auto *file = static_cast<FILE *>(userdata);
			fprintf(file, "%s", message);
			fflush(file);
		}, log_file);
	}
}

StateRecorder *Instance::getStateRecorderForDevice(const VkPhysicalDeviceProperties2 *props,
                                                   const VkApplicationInfo *appInfo,
                                                   const VkPhysicalDeviceFeatures2 *features)
{
	auto appInfoFeatureHash = Hashing::compute_application_feature_hash(appInfo, features);
	auto hash = Hashing::compute_combined_application_feature_hash(appInfoFeatureHash);

	std::lock_guard<std::mutex> lock(recorderLock);
	auto itr = globalRecorders.find(hash);
	if (itr != end(globalRecorders))
		return itr->second.recorder.get();

	auto &entry = globalRecorders[hash];

	std::string serializationPath;
	const char *extraPaths = nullptr;
#ifdef ANDROID
	serializationPath = "/sdcard/fossilize";
	auto logPath = getSystemProperty("debug.fossilize.dump_path");
	if (!logPath.empty())
	{
		serializationPath = logPath;
		LOGI("Overriding serialization path: \"%s\".\n", logPath.c_str());
	}
#else
	serializationPath = "fossilize";
	const char *path = getenv(FOSSILIZE_DUMP_PATH_ENV);
	if (path)
	{
		serializationPath = path;
		LOGI("Overriding serialization path: \"%s\".\n", path);
	}
	extraPaths = getenv(FOSSILIZE_DUMP_PATH_READ_ONLY_ENV);
#endif

	bool needs_bucket = infoFilter && infoFilter->needs_buckets(appInfo);

	// Don't write a bucket if we're going to filter out the application.
	if (needs_bucket && appInfo && infoFilter && !infoFilter->test_application_info(appInfo))
		needs_bucket = false;

	char hashString[17];

	sprintf(hashString, "%016" PRIx64, hash);
	if (!serializationPath.empty() && !needs_bucket)
	{
		serializationPath += ".";
		serializationPath += hashString;
	}
	entry.interface.reset(create_concurrent_database_with_encoded_extra_paths(serializationPath.c_str(),
	                                                                          DatabaseMode::Append,
	                                                                          extraPaths));

	if (needs_bucket)
	{
		char bucketPath[17];
		Hash bucketHash = infoFilter->get_bucket_hash(props, appInfo, features);
		sprintf(bucketPath, "%016" PRIx64, bucketHash);

		// For convenience. Makes filenames similar in top-level directory and bucket directories.
		auto prefix = Path::basename(serializationPath);
		if (!prefix.empty())
			prefix += ".";
		prefix += hashString;

		entry.interface->set_bucket_path(bucketPath, prefix.c_str());
	}

	entry.recorder.reset(new StateRecorder);
	auto *recorder = entry.recorder.get();
	recorder->set_database_enable_compression(true);
	recorder->set_database_enable_checksum(true);
	recorder->set_application_info_filter(infoFilter);
	if (appInfo)
		if (!recorder->record_application_info(*appInfo))
			LOGE_LEVEL("Failed to record application info.\n");
	if (features)
		if (!recorder->record_physical_device_features(*features))
			LOGE_LEVEL("Failed to record physical device features.\n");
	recorder->init_recording_thread(entry.interface.get());

	return recorder;
}

}
